Great. I’ll investigate the full taxonomy of a MadCap Flare project and its HTML5 output—including source structure, content organization, variables, snippets, conditions, TOC, and how these can be translated into Docusaurus-compatible Markdown. I’ll get back to you shortly with a comprehensive breakdown.


# MadCap Flare Project Structure and Conversion to Docusaurus Documentation

## Overview of Flare Project Organization

MadCap Flare organizes content into a **project** comprising two main directories by default: a **Content** folder for source content files and a **Project** folder for project configuration files. At the root of the project is an XML project file (`.flprj`) that defines global project settings. All Flare files use XML format (often XHTML for topics) – Flare projects are entirely open and editable as XML. This structure enables easy parsing and conversion since every topic, TOC, snippet, etc., is an XML document.

* **Content Folder:** Contains all authoring assets such as **topics**, **snippets**, **images**, and **stylesheets** (CSS). Authors can organize this folder into any subfolder hierarchy needed (e.g. grouping topics by section or feature).
* **Project Folder:** Contains supporting project files like **table of contents** (TOC) definitions, **target** files, **skin** files (for HTML templates/UI), **condition tag sets**, **glossaries**, etc. These are managed in Flare’s *Project Organizer*. (Flare also creates auxiliary folders like **Output** for generated output, and others for analysis and source control cache, but these do not contain source content.)

**Flare Project File Types:** The table below summarizes key file types in a Flare project and how each is used:

| **File Type**          | **Extension**  | **Description and Role**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ---------------------- | -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Topic files**        | `.htm` (XHTML) | **Topics** are the primary content files. Each topic is a standalone, XML-based XHTML file containing text, headings, images, and links about a specific subject. Topics are the modular building blocks of the documentation (analogous to pages or articles).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **Table of Contents**  | `.fltoc`       | **TOC files** define the navigation hierarchy. A TOC XML file contains a tree of `<TocEntry>` elements with *Title* and *Link* attributes pointing to topics or nested TOCs. This controls the structure and sequence of topics in outputs (for online help navigation or print order). Flare projects can have multiple TOCs (e.g. one per output or language), all stored under the Project > TOCs folder.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| **Snippet files**      | `.flsnp`       | **Snippets** are reusable content fragments (chunks of formatted XML content). A snippet might be a paragraph, a formatted note box, a table, or any combination of elements that is reused in multiple topics. Snippet files are stored typically in Content > Resources > Snippets. Authors insert them into topics, allowing single-sourced updates: editing the snippet file updates all topics that include it. In the XML, an inserted snippet appears as a reference element (e.g. `<MadCap:snippetBlock src="...">` for block-level snippets) rather than duplicating content in each topic.                                                                                                                                                                                                                                                                                |
| **Variable sets**      | `.flvar`       | **Variables** are placeholders for text (product names, version numbers, etc.) that may change or be output-specific. Variables are defined in Variable Set files (`.flvar`) stored under Project > Variables. A variable set contains multiple named variables each with a definition (value). Authors insert variables into topics (as small XML spans or markers) instead of literal text. When generating output, Flare replaces these with the current definition. Flare even allows multiple definitions per variable for different targets (e.g. a `ProductName` variable might have “Pro” for one target and “Lite” for another) – the target configuration picks which value to use.                                                                                                                                                                                       |
| **Condition tag sets** | `.flcts`       | **Condition tags** support conditional text for single-sourcing. A condition tag set file lists named condition tags (often organized by category). Authors can apply these tags to content spans, blocks, or entire topics to mark them for inclusion/exclusion in specific outputs. In the XML, conditioned content is wrapped in a `<MadCap:conditionalText>` element with a `MadCap:conditions` attribute naming the tag(s). Each target defines which condition tags are included or filtered out during generation. This allows one Flare project to produce variants of documentation (e.g. “Basic” vs “Advanced” features, or platform-specific content) from the same source.                                                                                                                                                                                              |
| **File tag sets**      | `.flfts`       | **File tags** are arbitrary metadata tags that can be applied to files (topics, etc.) for organizational purposes. For example, a team might tag topics with “Draft” or assign authors or milestones. These tags do not affect the output content; they are primarily for project management and can be ignored during conversion to Markdown.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **Target files**       | `.fltar`       | **Targets** define output *publishing configurations*. A target file is essentially a recipe for building a specific output (e.g. *HTML5 Help*, *PDF*, *Clean XHTML*, etc.). Each target specifies the output format and options like which master TOC to use, which condition tags to include/exclude, which variable set values to apply, the selected skin (for HTML outputs), and other output-specific settings. In Flare’s UI, targets are listed under Project > Targets. For example, an HTML5 target might reference the “Online\_Help.fltoc” TOC, include only “Platform=Web” conditional content, use the “Responsive” skin, and apply certain variable overrides. In essence, *Targets = output configuration files*. (One often-used target type is **Clean XHTML**, which produces simplified static HTML output of topics without the full HTML5 navigation system.) |
| **Skin files**         | `.flskn`       | **Skins** define the look-and-feel of the output’s UI chrome for online outputs. For HTML5 outputs, a skin might control navigation style (side-nav, top-nav, tri-pane), toolbar buttons, colors, etc. Skins are stored under Project > Skins and are XML files. When generating output, Flare uses the skin settings to produce the necessary HTML/CSS/JS framework around the content. (For conversion to Docusaurus, skin files are not directly used, since Docusaurus will handle navigation UI.)                                                                                                                                                                                                                                                                                                                                                                              |
| **Stylesheets (CSS)**  | `.css`         | Flare uses standard CSS stylesheets to control content styling. These appear in the Content folder (often under Resources > Stylesheets). Flare may have multiple CSS files for different purposes: a **regular stylesheet** for general content (headings, paragraphs, etc.), a **table stylesheet** for table-specific classes, and perhaps a **branding stylesheet** for product-specific branding elements. All topics link to one or more of these CSS files (Flare manages these links via the Project settings or Master Pages). During conversion, the CSS can be carried over or translated to Docusaurus theme custom CSS as needed.                                                                                                                                                                                                                                      |

**Additional file types:** Flare projects can include other files such as **glossaries** (`.flglo` for lists of terms and definitions), **index** files, **TOC browse sequences** (`.flbrs`), **relationship tables** (`.flrtb` for linking related topics), **search filter sets** (`.flsfs` for defining filters on search), and **master pages**/page layouts for print outputs. These all reside in the Content or Project folders as appropriate. For the scope of conversion to Docusaurus (a static site generator focusing on topics and navigation), the primary concern is topics, TOCs, reusable content (snippets/variables), media, and conditions as outlined above.

## Internal Structure of Topics and Fragments

Each **topic (`.htm`) file** in Flare is essentially a well-formed XHTML document. It typically includes a `<head>` (with metadata like topic title, keywords, etc.) and a `<body>` containing the content. The body holds the text, which can include standard XHTML elements (`<p>`, `<h1>...<h6>`, `<ul>/<ol>` lists, tables, `<img>` for images, etc.) as well as Flare-specific XML extensions in the MadCap namespace for certain features. For example:

* **Cross-references:** Flare distinguishes *cross-references* (dynamic links that auto-fetch the target title or other text) from normal hyperlinks. In the XML, a cross-reference is represented by a `<MadCap:xref>` element (in the `MadCap` namespace) with an `href` to the target topic or bookmark. The link text may be generated via a format setting. For instance, a cross-reference might appear as:

  ```xml
  <MadCap:xref href="../Guide/Installing.htm">See "Installing" on page 12</MadCap:xref>
  ```

  In this example, the cross-ref points to *Installing.htm* (using a relative path) and the inner text “See ‘Installing’ on page 12” is automatically generated by Flare’s cross-reference format settings. In many cases (especially for online outputs), Flare’s default cross-reference format is just the target topic’s title or heading text. In any case, the underlying output will be a standard hyperlink `<a>` tag. For conversion, these `<MadCap:xref>` elements need to be turned into Markdown links, using the appropriate link text (usually the topic title or heading).

* **Images:** Images in topics are inserted as regular HTML `<img>` tags with a relative path source. For example: `<img src="Resources/Images/archDiagram.png" alt="Architecture diagram">`. The image files (PNG, JPEG, etc.) are stored in the Content folder (often under a dedicated Images or Resources subfolder). Flare keeps image references relative to the project, which ensures they resolve correctly in output. When Flare builds output, it copies these images to the output directory maintaining the folder structure (unless configured otherwise). In conversion, these become Markdown images (e.g. `![Alt text](../Resources/Images/archDiagram.png)`) or can remain HTML `<img>` tags in MDX – the key is to preserve correct relative linking and include the image files in the Docusaurus project.

* **Media (videos, multimedia):** Flare topics may include multimedia by embedding HTML5 video/audio tags or via Flare’s YouTube/Vimeo widgets. For local videos, Flare would copy the media file into the output. These are relatively infrequent in documentation projects; if present, they can be handled by converting to equivalent MDX (for example, using an HTML `<video>` tag or an iframe for YouTube in the Markdown). Ensure the media file is placed in Docusaurus’s static folder and the link updated.

* **Drop-downs and togglers:** Flare allows interactive content like drop-down text (clickable headings that show/hide content) via *Dropdown* or *Expanding Text* controls. In the XML, a drop-down is typically represented by a `<MadCap:dropDown>` element containing a *DropDownHead* and *DropDownBody*. For instance, a simplified representation might be: `<MadCap:dropDown><MadCap:dropDownHead>Hint</MadCap:dropDownHead><MadCap:dropDownBody>...hidden content...</MadCap:dropDownBody></MadCap:dropDown>`. Such structures don’t have a direct Markdown equivalent. In conversion, a best practice is to either **convert them to static content** (always visible, perhaps preceded by a bold heading “Hint:”) or use an HTML `<details><summary>` block in MD, which provides similar functionality in a static site. The decision would depend on whether preserving the toggle behavior is important. (Docusaurus supports MDX, so including a `<details>` HTML block is feasible if interactivity is desired.)

* **Snippet references:** When a snippet is inserted into a topic, Flare does **not** duplicate its content in the topic file; instead it places a reference tag. There are two forms: `<MadCap:snippetBlock>` for block-level snippets (inserted on their own line) and `<MadCap:snippetText>` for inline snippets (inserted within a paragraph text flow). These elements have an attribute (like `src` or `MadCap:href`) pointing to the snippet’s `.flsnp` file. For example, a block snippet reference might look like: `<MadCap:snippetBlock src="../Resources/Snippets/Note.flsnp" />`. When previewing or building, Flare merges the snippet content at that location. In conversion, the strategy must be to **resolve snippet references** by reading the snippet file and injecting its content into the MD file (to avoid broken links). Snippet files themselves are XML fragments – effectively mini-topics that often contain a sequence of block elements (or sometimes just a single paragraph or table). They may also include their own references to images or even other snippets (nesting is possible). A reliable converter should recursively resolve snippet references to produce a single consolidated Markdown file for each topic.

* **Variables in topics:** Flare variables appear in the topic XML as small empty elements or text tokens that reference a variable name. While the Flare XML editor visually shows the variable’s name or value as a marker, the underlying XML might use a syntax like a span with a data attribute or a MadCap-specific tag. (For example, older versions used an `MadCap:variable` element or a syntax like `{VariableName}` inside text – the exact XML representation can vary by Flare version and is often handled behind the scenes.) Regardless of how they appear, when generating, Flare will replace those with the actual value. For conversion, one should replace variables with their defined value *for the chosen target*. If the project has multiple variable sets or definitions per target, use the value from the appropriate target’s context. For example, if a topic says “Welcome to \[ProductName]”, and `ProductName` is a variable, and for the “User Guide” target the value is “SuperApp Pro 2025”, the Markdown should contain “Welcome to SuperApp Pro 2025”. Essentially, perform a find-and-replace using the `.flvar` definitions for all variables.

## HTML5 Output Structure and Relation to Source

When Flare builds an **HTML5 output**, it generates a set of files that mirror the source content structure plus additional output-specific assets. By default, the output for each target is placed under the project’s `Output` folder, in a subdirectory named after the target (with a further subfolder for the user’s name, if using default settings). For example, if the project is in `C:\MyProject` and the target is “Online\_Help”, the HTML5 output might be generated to `C:\MyProject\Output\<Username>\Online_Help\`. This target output folder contains all the files that need to be deployed for that help site.

Key characteristics of HTML5 output structure:

* **Content files:** Flare will produce a standalone HTML file for each topic that is included in the output (usually all topics referenced in the target’s TOC, plus any linked via cross-references or search unless explicitly excluded). By default, Flare preserves the **Content folder structure** in the output (this is configurable; authors can choose to “flatten” the output by not including the Content folder, but typically the structure is retained). For instance, if topics were organized in `Content\Guide\Intro.htm`, the output may contain an `Intro.htm` in a corresponding `Content/Guide/` folder (or just `Guide/` folder, depending on settings). This 1:1 mapping is helpful: you can trace an output HTML file back to its source `.htm`. The filenames remain the same as the source (unless you used Flare’s target setting to rename outputs). All embedded content like images are copied into the output in their relative paths. **Bottom line:** each Flare topic becomes an HTML page in the output site, with the same name and a similar folder path.

* **Main entry file:** HTML5 outputs typically include a *start page*, often named `index.htm` or `Default.htm` at the root of the output (target folder). For *Top Navigation* or *Side Navigation* HTML5 outputs, this might be an index page that loads the initial content (sometimes the default topic) along with the navigation menu. In older *Tri-pane* outputs, the start page was a frameset or script that loads the TOC, index, etc. Modern HTML5 outputs (Top/Side nav) are frameless; they usually include a built navbar on each page or load navigation via scripts.

* **Output support directories:** Flare generates additional directories like **Data**, **Resources**, **Skin**, etc., in the output.

  * The **Data** folder contains XML/JSON files used by the output’s script for dynamic elements. For example, `Data/Toc.xml` (or sometimes `Data/TOCs/YourTOC.xml`) contains the structured TOC data derived from the project’s `.fltoc` file. Similarly, `Data/Search.xml` or `Search.json` might contain pre-built search indexes, and `Data/Glossary.xml` the glossary terms, etc. These data files allow the JavaScript in the HTML5 output to build menus and search results on the fly in the browser. Docusaurus, by contrast, will not use these files – it generates its own navigation and search indexes – so they are not needed when converting.
  * The **Skin** (or **Scripts**/**Styles**) folder holds the styling and scripts for the output’s user interface. Flare will bundle the CSS (both from your stylesheets and skin styles) and necessary JS (for toggling menus, search functionality, etc.). For example, you might see files like `Skin/style.css`, `Skin/MasterPage.css`, or a `Skin.js`, along with icon images or fonts for the webhelp toolbar. These ensure the Flare output has the expected look and feel. In migrating to Docusaurus, these UI artifacts aren’t directly used (since Docusaurus has its own CSS/JS), but **if you have custom CSS for content** (beyond basic styling), you may need to carry some of those styles into Docusaurus’s custom CSS.
  * A **Resources** folder in output might contain other assets (depending on how Flare was configured). Often, *Resources* might hold theme files or additional libraries. In some outputs, user images might be in `Content/Resources` vs. a separate images folder; Flare will replicate that structure.

* **Relationship to source files:** There is generally a direct correspondence – each source topic (.htm) yields an output .htm file. The TOC XML in output is generated from the source .fltoc. For instance, every `<TocEntry>` in the source TOC becomes a node in the output’s Toc.xml (with resolved links to .htm output files). If a source TOC linked to another child TOC or a whole directory of topics, the output will have merged those into one navigation structure.

* **Search and index:** If the Flare project had index markers or search filter tags, Flare’s build will compile those into index files (for example, an `Index.xml` or similar in the Data folder). Docusaurus has its own search (usually through Algolia or client-side indexing of content) and doesn’t use a precompiled index file, so these would not be migrated as-is. Instead, the content conversion must ensure that any **index-like information** (like keywords or tags) are either embedded in the content or annotated in frontmatter if needed for search. Often, it’s acceptable to rely on Docusaurus’s full-text search, but if the project had carefully curated search **filters** (Flare’s search filter sets), you might emulate those by tagging content and using a custom search plugin on Docusaurus.

In summary, Flare’s HTML5 output is a fully functional static website closely mirroring the source project’s structure: all source content (after applying snippets, variables, conditions) is present as HTML pages, and supplemental files (TOC, scripts, styles) enable the interactive help system. **For conversion to Docusaurus, it’s usually best to work from the Flare source** rather than the output, because the source retains the semantic markers (snippets, variables, conditions) that need processing. However, understanding output structure is useful: it validates that each topic stands alone as an HTML page and shows how the TOC and links resolve.

*Tip:* Flare offers a special target type *“Clean XHTML”* which generates each topic as a simplistic, full HTML file without the extra menu scripts (essentially just the topic content in a basic HTML page). Some conversion workflows use Clean XHTML output as the starting point for Markdown conversion, since those files have all snippets and variables already resolved and contain minimal Flare-specific markup. The downside is you lose some structure information (e.g., which parts were conditional or snippet boundaries – they are merged in output). If starting from raw source, you will perform those merges yourself, which gives you more control.

## How Flare Handles Navigation (TOC) and Single-Sourcing

Flare is built for single-sourcing, meaning you can produce multiple outputs (help center, PDF manual, etc.) from one source by using structures like TOCs, conditions, and targets:

* **Table of Contents (TOC):** Flare’s TOC files (`.fltoc`) define *hierarchical navigation*. Each TOC is an XML file with a root `<CatapultToc>` element containing nested `<TocEntry>` elements. Each `<TocEntry>` typically has a `Title` attribute (the label shown in nav) and a `Link` attribute pointing to a topic file or other file. For example:

  ```xml
  <CatapultToc Version="1">
    <TocEntry Title="Introduction" Link="/Content/Guide/Intro.htm" />
    <TocEntry Title="User Guide" Link="/Project/TOCs/UserGuide.fltoc"></TocEntry>
    <TocEntry Title="FAQ" Link="/Content/FAQ.htm" />
  </CatapultToc>
  ```

  In this snippet, the first entry links directly to a topic, the second entry links to another TOC (allowing TOC merging), and the third to a topic again. Flare supports **nested TOCs**: an entry can reference another .fltoc, which gets merged into the parent TOC at that point (there’s even a property to *merge in* the child TOC’s nodes in place of the parent node if desired). Flare’s TOC entries can also point to *external* resources (like a URL or a PDF) or even a *Flare target* (which in output becomes a link to another output). In practice, most entries link to topics or serve as headings (a TocEntry with no Link is just a category heading in the menu).

  The *navigation hierarchy* in the output is built from the TOC. For HTML5 outputs, the TOC provides the structure of menus (side navigation tree or top dropdown menus). For print outputs (like PDF), the TOC order defines the chapter/section ordering and can generate a table of contents page and PDF bookmarks.

  **Mapping to Docusaurus:** Docusaurus uses a *sidebar configuration* (often a JavaScript or JSON file named `sidebars.js`) to define the navigation tree for docs. We will extract the Flare TOC structure and convert it into Docusaurus sidebar format. Typically, each Flare `TocEntry` that links to a topic becomes a sidebar link item, and entries that served as containers (folders with child entries and maybe no direct link) become sidebar categories. Docusaurus supports nested categories, so the hierarchy can be preserved. For example, a Flare book (non-clickable heading) with children would become a Docusaurus category with those children as items. If a Flare TOC entry both has content *and* children (a book that is also a link), one approach is to treat the parent as a category and also include the linked topic as the first item under it (or use the special Docusaurus ability to have a category with an *index* page). We will ensure the sidebar *order and nesting* mirror the Flare TOC so the documentation structure remains the same.

* **Conditional text:** Flare’s condition tags allow fine-grained filtering of content for different outputs. Authors can apply condition tags to pieces of content (down to a phrase or image), entire paragraphs/sections, *or entire files*. For example, a paragraph might be tagged “EnterpriseOnly” to include it only in an Enterprise edition output. In the XML, such a span would be wrapped like: `<MadCap:conditionalText MadCap:conditions="EnterpriseOnly">This feature is enterprise-only.</MadCap:conditionalText>`. If multiple conditions apply, the attribute can list them (Flare treats it essentially as OR by default, unless using advanced “AND” expressions via tag combinations). In Flare’s target settings, you choose which conditions to include or exclude. Any excluded content is completely omitted from that target’s output.

  Flare’s *single-sourcing strategy* often combines conditions with multiple targets: e.g. one project can maintain **one set of topics** that document both *Product A* and *Product B*, using condition tags “ProdA” and “ProdB” on relevant content, and then two targets build two outputs (one including only ProdA content, one ProdB). Similarly, print vs web differences (like “PrintOnly” sections) can be handled via conditions. Condition tags can also apply to whole topics or TOC entries – you can mark a topic file with a condition (via File Properties), so that if that condition is excluded, the topic is omitted from output (and any TOC entries linking to it might be dropped). In practice, Flare uses condition tags on TOC entries to hide them in certain outputs (this might not be an explicit attribute in the .fltoc XML, but Flare’s build process knows to skip those entries when generating the output TOC file).

  **Mapping to Docusaurus:** Docusaurus does not have a native conditional text feature for building variants of the site – typically, you would maintain separate versions or use React components logic if truly needed. Therefore, for a given static site, we will choose one configuration of content. In other words, decide upfront which conditions’ content should be included. This will likely correspond to one of the Flare targets. The converter should be run in the context of a specific target or conditional profile. All content *not* meant for that output must be filtered out during conversion (excluded). Content that is included can have the condition markers removed (since in a single static site they no longer serve a purpose once the filtering decision is made). For instance, if converting the “Online Help” target and it excludes “PrintOnly” content, the converter will drop any `<MadCap:conditionalText MadCap:conditions="PrintOnly">...</MadCap:conditionalText>` sections entirely. If some content has multiple condition tags and the target includes one but not the other, apply the logical combination as Flare would. Essentially, implement the same filtering rules as the Flare target.

  If there is a need to maintain **multiple outputs** (say HTML and PDF) using Docusaurus, you might handle this by maintaining multiple versions of the site or using Docusaurus’s versioning or multi-instance approach – but that’s outside the core conversion (the straightforward path is one Docusaurus site per Flare target).

* **Variables in single-sourcing:** As noted, Flare variables can have different values per target (e.g. a single source that outputs for USA vs UK might have a “TaxRate” variable value differ). In Flare’s Target Editor, on the Variables tab, you can override any variable’s definition. The converter needs to respect that: if we convert using the “UK” target, we should replace variables with UK values. A robust converter might actually read the `.fltar` XML (which likely includes sections for overridden variable values and condition include/exclude lists) to automate this. The Flare target file is XML (though not publicly documented in detail) – it contains child elements or attributes defining the selected TOC, the skin, and conditions/variables. By parsing it, one could get the active variable set and any overrides.

* **Snippets and reuse:** Snippets serve single-sourcing by letting you maintain one copy of repetitive content. For conversion, after we merge snippet content into the topics, we end up with fully expanded topics (which is fine for static site output, albeit losing the single-point-update capability). There is no direct analog to Flare snippets in static Markdown, except using MD includes or templates, but Docusaurus does not natively support content inclusion by reference (aside from manual React components). Thus, the safest path is to inline all snippet content. (If maintainability of duplicate content post-conversion is a concern, one could devise a scheme using MDX components or partials, but that gets complex and is usually not required unless the content will continue to be maintained in Markdown.)

* **TOC and multi-TOC single sourcing:** Flare allows multiple TOCs which can even *link* to each other or be merged. For example, a parent product TOC might include a child product’s TOC. If your Flare target uses a single master TOC (even if it links others), the Flare build resolves it into one navigation. For Docusaurus, we will similarly produce one unified sidebar. If multiple distinct TOCs were used for different targets, you would generate a separate sidebar for each Docusaurus site or use Docusaurus’s support for multiple sidebars (if you are combining them into one site for different sections). But typically, one site = one TOC.

In short, **the Flare project’s single-sourcing constructs (conditions, variables, snippets)** must be *resolved* according to a chosen configuration when migrating to a static site. The Flare TOC gives us the structure which we’ll map to Docusaurus sidebars, ensuring the navigation and hierarchy remain intact.

## Conversion Strategy: From Flare to Docusaurus Markdown

Converting a Flare project to Docusaurus involves **extracting the content and structure** from Flare’s XML files and transforming them into Markdown files with YAML frontmatter and a corresponding sidebar configuration. This process can be complex due to the Flare-specific constructs. Here we outline a recommended approach and best practices for a reliable converter:

### 1. Choose the Output Profile (Target)

First, determine which Flare *target* (output) you are converting. All filtering of content (conditions) and variable values should align with that target’s settings. As a best practice, **export one Flare target at a time** to a Docusaurus site. For example, if Flare has separate targets for “User Guide HTML5” and “Admin Guide HTML5”, you would convert each separately (perhaps into different sections or versions of a Docusaurus site). By selecting a target, you know which TOC to use, which conditions to apply, and which variable definitions to pick.

> **Why specify a target?** As a Flare expert on the forums explains, *“the trouble with a general 'export to Markdown' tool is not just HTML-to-Markdown conversion – you must resolve all the MadCap-specific components first. You’d have to specify a target so you can look up variable settings and condition settings, and then process the topic (convert xrefs, expand snippets, etc.)”*. In other words, Flare’s content is context-dependent; a converter needs the target context to know what the final content should look like.

### 2. Extract the TOC Structure

Parse the Flare TOC (`.fltoc`) file for the chosen target (as set in the target’s “Master TOC” setting). This XML gives the hierarchical list of topics in the desired order. Build an in-memory representation of the TOC tree: each entry has a title, a link (which is a path to a topic or sub-TOC), and possibly children entries.

For conversion to Docusaurus:

* Create a **sidebar configuration** that mirrors this structure. In Docusaurus v2, this is typically a JS object exported from `sidebars.js`. For example, you might create an object like:

  ```js
  module.exports = {
    mySidebar: [
      {
        type: 'category',
        label: 'User Guide',
        items: [
          'guide/intro',       // corresponds to Intro.md
          {
            type: 'category',
            label: 'Installation',
            items: [
              'guide/install/requirements',
              'guide/install/windows',
              'guide/install/linux',
            ],
          },
          'guide/FAQ'
        ]
      }
    ]
  };
  ```

  This is a conceptual example; the actual structure and item IDs will depend on your file paths and TOC. The `'label'` comes from `TocEntry@Title` and each item corresponds to a Markdown document. If a Flare TOC entry was just a container (no Link), we represent it as a Docusaurus category (non-linking group). If it was a linking entry (points to a topic), we ensure there’s a corresponding MD file and reference it.

* **Filename and ID mapping:** Decide on a mapping from Flare topic files to Markdown file paths. Often you can retain the same filenames (e.g., `Intro.htm` → `Intro.md`) and folder structure. Docusaurus will use the file’s path (or an explicit *id* in frontmatter) to identify the doc. It’s wise to use lowercase, hyphenated filenames for URLs, but Docusaurus can handle mixed-case if needed. Consider replacing spaces or special chars if any in filenames. The goal is that internal links and sidebar references remain consistent. You might choose to drop the `.htm` extension in naming (e.g., a file `Intro.htm` becomes `intro.md` in the `guide/` folder, and you’d reference it as `guide/intro` in the sidebar config).

* **Nested TOCs:** If the Flare TOC had an entry that linked to another TOC (common when large projects are merged), by reading that sub-TOC file you can inline its entries as children in the main structure. Flare may also have *browse sequences* (an alternate linear navigation) but Docusaurus primarily uses the hierarchical sidebar and previous/next navigation based on that – browse sequences can be ignored or handled by ensuring a logical order of docs (Docusaurus will by default generate prev/next from the sidebar order).

### 3. Convert Topic Files to Markdown

This is the core of content conversion. For each topic that will be included (all topics referenced in the TOC, plus any additional topics that are cross-referenced), perform the following:

* **Open and parse the `.htm` topic XML.** Using an XML parser (to handle well-formed XHTML and namespaces properly) is strongly recommended over regex or text matching. This allows you to locate elements like `<MadCap:snippetBlock>`, `<MadCap:conditionalText>`, `<MadCap:xref>`, etc., systematically.

* **Apply condition filtering:** Traverse the XML and remove any elements (or element content) that should be excluded per the target’s conditions. For example, if an element `<MadCap:conditionalText MadCap:conditions="Internal">Secret</MadCap:conditionalText>` has a condition “Internal” that is not included in the chosen target, you would drop that element entirely (nothing of “Secret” goes into the output). If an element has multiple conditions in its attribute, include it only if *all* required conditions for this output are met (Flare’s condition logic is additive by default, but there are advanced cases with multiple condition sets – typically, treat it as a content that is included if any one of its conditions is included by target, unless the Flare project was using an “AND” convention via combined tags). Also remove the `MadCap:conditionalText` wrapper tags themselves for any content that *is* included (the content inside just becomes normal text).

* **Resolve snippets:** Whenever you encounter a snippet reference (`<MadCap:snippetBlock>` or `<MadCap:snippetText>`), open the referenced `.flsnp` file. Recursively process that snippet file’s content through the same filtering and conversion steps (snippets can contain variables, conditions, even other snippets). Once processed, inline the snippet’s content in the place of the reference. Essentially, you *merge* the snippet. This may involve merging XML structures; ensure that block-level snippets end up as proper block elements in Markdown. For example, if a snippet contains a list of steps as `<ol><li>Step1</li><li>Step2</li></ol>` and it’s inserted as a block, make sure in Markdown you get a proper ordered list at that location. If inserted as inline (snippetText), ensure it flows within the sentence properly (e.g., if it was a snippet for a product name, it should just become the text of that name).

* **Replace variables:** Look for occurrences of variables. Depending on how Flare marks them, they might appear as an empty element `<MadCap:variable name="ProductName"/>` or some placeholder text. In an XML parse, you might identify them via a known pattern or by cross-referencing the text with known variable definitions. The easier method is to perform a **post-XML-pass text substitution**: after removing tags for conditions and snippets, you can take the intermediate HTML and do replacements for each variable name with its value. Since you have the list of variables from the `.flvar` file (and any target-specific overrides), you can reliably substitute. For example, replace all occurrences of `MadCap:variable name="Year"` with `2025` (assuming Year=2025). Be careful to avoid replacing unintended text – ideally match the exact XML pattern or surrounding markers of the variables. After replacement, the content should have no Flare variables left, just static text.

* **Convert cross-references and links:** For any `<MadCap:xref>` element, convert it to a standard Markdown link. This means:

  * Determine the target of the xref: usually the `href` attribute (which might be like `"..\Guide\Topic.htm#Bookmark1"` or just `"Topic.htm"`). Make that into a link path that matches the Markdown file of the target. For example, `../Guide/Topic.htm` → `../Guide/Topic.md` (or whatever the target’s new name is). If you are using pretty links (without .md extension in links), adjust accordingly (Docusaurus allows linking by doc ID or by relative path without extension).
  * Determine link text: The content of `<MadCap:xref>` might already contain the resolved text (Flare often stores the last generated text inside the element). In our earlier example, the xref inner text was *“See "Installing" on page 12”*. Since we are making a *single HTML documentation site*, we likely do not want “on page 12”. We might prefer just “See “Installing”” or even just “Installing” as the link text. If the xref uses a format that inserts a page number (which was intended for print PDFs), you should omit that part for the web output. In many cases, if the xref was using the default online format, the inner text might simply be the heading of the target topic. As a converter, you can either trust the given inner text or, for greater accuracy, open the target topic and extract its title (e.g., the text of its first heading) to use as link text. This ensures the link text remains correct even if the Flare cross-reference format was complex or if you want consistency.
  * Finally, output a Markdown link. For example:

    ```markdown
    [See "Installing"](./installing.md)
    ```

    (The exact path depends on where the file resides in the new docs structure.)

  Normal hyperlinks in Flare topics (`<a href="http://...">` or `<a href="../otherTopic.htm">`) that were not managed as xrefs can be converted similarly. External links (starting with http\:// or https\://) can remain the same in Markdown (just use the absolute URL). Internal links to other topics or to anchors need updating to the Markdown file and possibly adjusting the anchor format. For in-page anchors: Flare’s topics might have named anchors or use IDs on headings. Docusaurus can link to headings via `#` and a slug (which is usually the heading text lowercased and hyphenated). You may want to ensure any named anchor links are converted to the appropriate MD link (which might be like `Page.md#section`). Preserve or map any anchor names: if a Flare link references `Topic.htm#AnchorName`, in the Markdown you should ensure the target MD has a corresponding anchor (perhaps by inserting `<a name="AnchorName"></a>` in the MD or by relying on a heading with that ID). This can be an advanced step – often, anchor links aren’t too common except for cross-reference to specific headings or using Flare’s *concept link* feature, which we can handle similarly.

* **Retain formatting and structure:** The content inside the topic’s body, after snippet and condition resolution, is essentially XHTML markup for the documentation content. Now the task is to convert that HTML to Markdown syntax where possible:

  * Headings `<h1>…<h6>` → `# … ######` in Markdown. It’s typical that Flare topics might use `<h1>` for the topic title in each file (or sometimes Flare doesn’t include an `<h1>` in the topic body and instead expects you to use the TOC entry as the title). If the topic’s first heading is missing or you want to enforce one, you could use the TOC Title or the topic file name to generate a top-level `# Title` in Markdown. However, if the Flare topic already has an `<h1>` title in content, keep that. Consider the hierarchy: if all topics have an H1 as title, in Docusaurus each MD file’s content would start with that H1 (which by default may be displayed along with the page). Alternatively, you might use the YAML frontmatter `title:` attribute to set the page title (which Docusaurus will display as an H1 automatically) and **downgrade the actual content headings by one level** (so that you don’t have two titles). This is a stylistic choice. Many conversions choose to put the topic title in the frontmatter and remove the explicit first heading from content to avoid duplication of page title.
  * Paragraphs `<p>` → just plain text separated by blank line in Markdown.
  * Lists `<ul><li>` and `<ol><li>` → `- ` bullet points or `1.` numbered points. Nested lists should maintain their indent levels (Markdown uses 2 or 4 spaces indent for each nesting).
  * Tables: You can use Markdown tables if the tables are simple enough (only plain text in cells). However, Flare tables often have complex formatting (colspans, rowspans, or nested elements). Markdown’s table syntax is limited. A pragmatic approach is to leave tables in HTML (which MDX will accept). Alternatively, if tables are simple and you want to convert, do so carefully. It might be safer to output tables as HTML `<table>` in the Markdown – Docusaurus will render it fine.
  * Images `<img src="...">` → Markdown image syntax `![alt text](path)` if possible. But if there are custom classes or attributes (width, etc.), you may leave the HTML image tag as is. Docusaurus MDX allows raw HTML, which will pass through.
  * Admonitions: If your Flare content has callouts like Note, Tip, Warning, often these are implemented via snippets (e.g., a “Note” snippet that inserts a styled note box with an icon). After conversion, you’ll have something like a blockquote or a div with a class. You might leverage Docusaurus admonitions syntax for a cleaner result. For example, convert a note like:

    ```html
    <div class="Note"><p><strong>Note:</strong> Remember to save your work.</p></div>
    ```

    into

    ```markdown
    :::note
    Remember to save your work.
    :::
    ```

    This requires recognizing certain patterns (maybe by class name or snippet name). It’s a nice-to-have improvement. At minimum, ensure such content isn’t lost: you can carry over the HTML or convert it to a blockquote (prepend `> ` to each line) to visually distinguish it.
  * Remove any Flare-only artifacts: For instance, Flare might insert an HTML comment like `<!-- MadCap begIndCond: ... -->` around conditional content, or include meta tags for search score, etc. Those should be stripped out. Also remove elements that won’t be used, like `<script src="MadCapAll.js">` or analytics scripts that Flare output might include in each topic – those won’t be needed in Docusaurus.

After this step, each topic should be converted into clean Markdown (with maybe some inline HTML for complex elements).

* **Add YAML frontmatter:** At the top of each Markdown file, include a YAML block with any metadata needed. The most common is `title: "..."` to define the page title (if you want Docusaurus to use it). You might set the title to the same as the Flare topic’s title or the TOC entry title. This ensures the sidebar label or the browser title will show the proper name. If you want custom sidebar labeling or to group in categories manually, you could also assign a `sidebar_label`, but since we are generating sidebars config, we might not need that (the sidebar config can specify the label separately). Other frontmatter could include `slug` if you want to control URL (by default Docusaurus slug is based on file path). For example, if you want `Intro.md` to have URL `/` (home page of docs), you could slug it accordingly or handle that in routing.

* **Filenames and linking:** Ensure that when you write the Markdown files to disk, their file paths correspond to how you referenced them in the sidebar and cross-links. For example, if `TopicA` in Flare linked to `TopicB.htm` via a cross-ref, and you converted `TopicB.htm` to `TopicB.md` in the same folder, then in `TopicA.md` you might have `[...](TopicB.md)`. Docusaurus will transform that into a correct link (during build it might become `TopicB` or `TopicB.html`). Alternatively, Docusaurus supports linking by document ID (which is basically derived from file path relative to docs/). For simplicity, using relative paths in links that mirror your folder layout is effective. Just remember to adjust “.htm” to “.md” in links while converting.

**Important:** Maintain proper linking and avoid broken references. A systematic approach is to keep a map of old Flare file paths to new MD file paths, and use that to rewrite links. Flare’s TOC and cross-ref usage ensures you know which topics connect to which. You may also scan for any plaintext references to “.htm” in content (like if someone hard-coded a hyperlink) and update them.

### 4. Bring Over Assets (Images, Downloads)

Docusaurus by default has a `/static` directory for static assets (which get copied to the build untouched). If you put an image in `static/img/diagram.png`, you can reference it in Markdown as `/img/diagram.png`. Alternatively, Docusaurus allows images to reside alongside the Markdown files (relative links will be transformed). Either approach works; the latter keeps images near content, the former centralizes them.

**Best practice:** Maintain the directory structure for media if possible. For instance, if Flare had `Content/Resources/Images/`, you could create a corresponding `docs/Resources/Images/` and have the MD refer relatively. Or copy all images to `static/img/` and update references accordingly (maybe even flatten if you prefer). The key is to ensure every `<img>` or media file referenced in the MD has a corresponding file in the new project.

Also, transfer any downloadable files (PDFs, etc.) that were linked in Flare, to the static folder and adjust links.

### 5. Verify and Enhance

After conversion, you will have a set of Markdown files and a sidebar definition. At this stage:

* **Build the Docusaurus site** and check that the sidebar appears as expected (same hierarchy as Flare TOC), all pages are present, and navigation (prev/next) goes in the right order (Docusaurus will default to TOC order).

* **Check links:** Click through cross-page links and image links to ensure none are broken. If any links were missed (e.g., a link in Flare that wasn’t in the TOC and you didn’t convert that topic), convert those topics too or adjust the link to an external reference if you chose not to bring that content.

* **Search:** Docusaurus will index the content of your Markdown for search. You might not need to do anything special, but if some important metadata (like Flare index keywords or search synonyms) were present, you could consider adding them as hidden text or using frontmatter tags (Docusaurus can use frontmatter like `tags: ["]` for categories, though not exactly the same as Flare index keywords).

* **Styling adjustments:** If certain styles didn’t carry over (for example, maybe text that was colored or formatted via a class in Flare), you have a couple options:

  * Add custom CSS in Docusaurus (in `src/css/custom.css`) to target those elements or classes. For example, if some paragraphs had a class `.Important` that gave a red highlight in Flare, you can carry that class into the HTML (it would appear in the MD as `<p class="Important">...</p>`) and then define `.markdown .Important { ... }` in Docusaurus CSS.
  * Alternatively, convert those to standard Docusaurus admonitions or other Markdown constructs as mentioned earlier.

* **Table of Contents on pages:** Docusaurus can automatically generate an in-page table of contents for headings (usually displayed on the right side). Flare also had a proxy for mini-TOCs (like a “On this page” for headings) or maybe used *h1 vs h2* to delineate topics vs subtopics. In Markdown, just using appropriate heading levels will let Docusaurus create that mini-TOC. No extra work needed aside from ensuring the hierarchy of headings is logical.

* **Pagination:** If the Flare browse sequence or default previous/next reading order is important, Docusaurus by default will consider the sidebar order as the doc ordering. That should suffice (the sidebar order is our TOC order). If you need a custom ordering separate from sidebar, Docusaurus allows overriding next/prev manually in frontmatter, but likely not needed.

### 6. Testing and Iteration

It’s likely you will iterate on the converter script or process. Here are **best practices** and tips learned from such migrations:

* **Automate with scripting or XSLT:** Given the repetitive nature (potentially hundreds of topics), writing a script (in Python, Node, etc.) to do the XML parse and conversion is ideal. Many have used XSLT (Extensible Stylesheet Language) to transform Flare XML to other formats since Flare’s XML is consistent. For example, you could write an XSLT to apply to each topic: it could remove MadCap namespaces, process snippets by extension functions, etc. Using an XML-aware tool ensures you handle things like entity references (Flare might use `&nbsp;` or others) properly and output well-formed Markdown (which is basically text). A combination of XSLT for structural transformation and some post-processing in a script can be effective.

* **Leverage existing tools cautiously:** There are some existing converters (e.g., a **MadCap Flare to Markdown** plugin by a third party, or open-source scripts like *flare-to-markdown* on GitHub). These can provide inspiration, but you must still verify that all nuances (conditions, cross-refs) are handled. If using them, ensure they allow specifying a target or otherwise incorporate conditions/variables (the plugin mentioned does convert all topics and snippets, but you'd still need to handle conditional exclusion manually by perhaps preparing a Flare target that excludes unwanted content and maybe using the *“exclude content not linked”* option to drop orphaned topics).

* **Preserve source control history (optional):** If maintaining the project history is important and you have the Flare project in source control, you might consider doing the conversion in a way that maps Flare files to Markdown files one-to-one so you could potentially trace back. In practice, this is rarely needed – treat it as a new project initialization in Docusaurus, with the Flare project as reference.

* **Documentation and team training:** Once converted, update your team’s workflow documentation. Authors used to Flare need to know how to update content in Markdown/MDX now. Some aspects (like adding a new page) require adding to sidebars.js, whereas in Flare one would add to a TOC – conceptually similar but done in code. Variables in Flare might be replaced by simple search/replace or templates in MD (or using partial includes), so establish how things like product name updates will be done (perhaps a global search, or use Docusaurus environment variables if needed for things like version numbers).

* **Quality check the content:** Read through some pages in the Docusaurus site and compare with the Flare output or source to ensure nothing significant was lost or altered. Pay attention to lists, special characters, code blocks, and tables – these often have formatting issues if conversion isn’t thorough.

By following these steps, you create a **maintainable Markdown-based documentation** that retains the structure and content of the original Flare project. The heavy lifting lies in converting the rich Flare XML (with single-sourcing features) into a simpler, static format. Once done, the documentation can be served via Docusaurus with all the benefits of a static site (fast loading, easy theming, versioning, etc.).

### Summary of Key Recommendations

* **Plan per target** – Extract content using one Flare target’s settings at a time to ensure correct inclusion/exclusion of content and proper variable values.
* **Use XML parsing** – Flare files are XML; leverage that to accurately identify and transform elements (topics, snippets, conditions, xrefs) rather than treating files as plain text. This avoids errors with nested tags or special characters.
* **Merge and replace** – Merge snippets in place and replace variables with their current values so that the Markdown output is self-contained with no dependencies on Flare-specific features.
* **Preserve structure** – Keep the topic hierarchy from the TOC. The user experience in Docusaurus should mirror the Flare help system’s organization. This includes sequence (for next/prev navigation) and grouping (sections).
* **Maintain links** – Ensure all cross-references and hyperlinks become functional links in the static site. Do not hard-code “.htm” extensions; use relative paths or Docusaurus doc IDs that will be resolved. It’s easy to accidentally break links during conversion, so use automated link mapping and consider validating links post-build.
* **Don’t skip the assets** – Copy over all images and media. A missing image in the docs can confuse users; if the Flare output had it, so should the Docusaurus site. Adjust paths in the Markdown or static folder so images load correctly.
* **Test frequently** – As you develop the conversion process, run the Docusaurus site locally to catch formatting issues early. It’s easier to tweak the conversion (e.g., how code snippets or notes are handled) when you can see the outcome immediately.
* **Leverage Docusaurus features** – Take advantage of Markdown enhancements like code blocks (for any sample code from Flare) or admonitions (for notes/warnings) to make the documentation look polished. Docusaurus also supports multi-language content and versioning; if your Flare project had those concepts (maybe via condition tags for version or language), you might integrate with Docusaurus’s approach (e.g., use Docusaurus Versioning for different releases rather than conditions).
* **Document the mapping** – It’s useful to document how each Flare construct was mapped. For example: *Condition “Internal” – excluded from public docs*, *Snippet “NoteBox” – converted to :::note admonition*, *Variable ProductName – replaced with “AcmePro”*, etc. This will help future maintainers understand the decisions made during conversion.

By meticulously converting the **complete taxonomy** of Flare project elements into Markdown, YAML, and other static site constructs, you set up a Docusaurus documentation site that should closely resemble the original Flare output in content and organization. The end result is that all **topics** become individual Markdown files, the Flare **TOC** becomes the Docusaurus sidebar, **snippets** and **variables** are resolved into the text, **conditions** are applied to include the right content, and **links/media** function properly in the new site. This thorough approach ensures nothing is lost in translation and the single-sourced content integrity is maintained in the new platform.

**Sources:**

* MadCap Flare 2025 Documentation: Flare project structure and file types.
* MadCap Flare for Programmers (Thomas Tregner’s blog): Examples of Flare TOC XML and usage of Flare-specific tags.
* Teklibri (Flare XML processing tips): Explanation of TocEntry link paths and cross-reference markup.
* Hyper/Word Services Blog: Single-sourcing in Flare (variables and conditions usage).
* MadCap Software Forums and Knowledge Base: Expert tips on Markdown conversion and Flare content handling.
* MadCap Software Blog: *Topics, TOCs, and Targets* (core Flare concepts).
